/*
 * Copyright (C) 2014 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import com.google.common.collect.ImmutableList;
import com.google.testing.compile.JavaFileObjects;
import javax.tools.JavaFileObject;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.common.truth.Truth.assertAbout;
import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT;

@RunWith(JUnit4.class)
public class ComponentProcessorTest {
  @Test public void componentOnConcreteClass() {
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component",
        "final class NotAComponent {}");
    assertAbout(javaSource()).that(componentFile)
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining("interface");
  }

  @Test public void componentOnEnum() {
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component",
        "enum NotAComponent {",
        "  INSTANCE",
        "}");
    assertAbout(javaSource()).that(componentFile)
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining("interface");
  }

  @Test public void componentOnAnnotation() {
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component",
        "@interface NotAComponent {}");
    assertAbout(javaSource()).that(componentFile)
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining("interface");
  }

  @Test public void nonModuleModule() {
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component(modules = Object.class)",
        "interface NotAComponent {}");
    assertAbout(javaSource()).that(componentFile)
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining("is not annotated with @Module");
  }

  @Test public void cannotReferToAbstractModules() {
    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module",
        "abstract class TestModule {}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component(modules = TestModule.class)",
        "interface BadComponent {}");
    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile))
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining(
            String.format(REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT, "test.TestModule"));
  }

  @Test public void doubleBindingFromResolvedModules() {
    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
        "package test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "import java.util.List;",
        "",
        "@Module",
        "abstract class ParentModule<A> {",
        "  @Provides List<A> provideListB(A a) { return null; }",
        "}");
    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
        "package test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "class ChildNumberModule extends ParentModule<Integer> {",
        "  @Provides Integer provideInteger() { return null; }",
        "}");
    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
        "package test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "import java.util.List;",
        "",
        "@Module",
        "class AnotherModule {",
        "  @Provides List<Integer> provideListOfInteger() { return null; }",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import java.util.List;",
        "",
        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
        "interface BadComponent {",
        "  List<Integer> listOfInteger();",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))
        .processedWith(new ComponentProcessor())
        .failsToCompile().withErrorContaining(
            "java.util.List<java.lang.Integer> is bound multiple times")
        .and().withErrorContaining(
            "@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)")
        .and().withErrorContaining(
            "@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
  }

  @Test public void simpleComponent() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  SomeInjectableType someInjectableType();",
        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.Lazy;",
        "import dagger.internal.DoubleCheckLazy;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return SomeInjectableType$$Factory.create().get();",
        "  }",
        "",
        "  @Override",
        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
        "    return DoubleCheckLazy.create(SomeInjectableType$$Factory.create());",
        "  }",
        "",
        "  @Override",
        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
        "    return SomeInjectableType$$Factory.create();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void componentWithScope() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "import javax.inject.Singleton;",
        "",
        "@Singleton",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "import javax.inject.Provider;",
        "import javax.inject.Singleton;",
        "",
        "@Singleton",
        "@Component",
        "interface SimpleComponent {",
        "  SomeInjectableType someInjectableType();",
        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.Lazy;",
        "import dagger.internal.DoubleCheckLazy;",
        "import dagger.internal.ScopedProvider;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
        "",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.someInjectableTypeProvider =",
        "        ScopedProvider.create(SomeInjectableType$$Factory.create());",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return someInjectableTypeProvider.get();",
        "  }",
        "",
        "  @Override",
        "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
        "    return DoubleCheckLazy.create(someInjectableTypeProvider);",
        "  }",
        "",
        "  @Override",
        "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
        "    return someInjectableTypeProvider;",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void simpleComponentWithNesting() {
    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
        "package test;",
        "",
        "import dagger.Component;",
        "import javax.inject.Inject;",
        "",
        "final class OuterType {",
        "  static class A {",
        "    @Inject A() {}",
        "  }",
        "  static class B {",
        "    @Inject A a;",
        "  }",
        "  @Component interface SimpleComponent {",
        "    A a();",
        "    void inject(B b);",
        "  }",
        "}");

    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_OuterType_SimpleComponent",
        "package test;",
        "",
        "import dagger.MembersInjector;",
        "import javax.annotation.Generated;",
        "import test.OuterType.A;",
        "import test.OuterType.B;",
        "import test.OuterType.SimpleComponent;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_OuterType_SimpleComponent implements SimpleComponent {",
        "  private MembersInjector<B> bMembersInjector;",
        "",
        "  private Dagger_OuterType_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.bMembersInjector =",
        "        OuterType$B$$MembersInjector.create(OuterType$A$$Factory.create());",
        "  }",
        "",
        "  @Override",
        "  public A a() {",
        "    return OuterType$A$$Factory.create().get();",
        "  }",
        "",
        "  @Override",
        "  public void inject(B b) {",
        "    bMembersInjector.injectMembers(b);",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_OuterType_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void componentWithModule() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class A {",
        "  @Inject A(B b) {}",
        "}");
    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
        "package test;",
        "",
        "interface B {}");
    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class C {",
        "  @Inject C() {}",
        "}");

    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "final class TestModule {",
        "  @Provides B b(C c) { return null; }",
        "}");

    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = TestModule.class)",
        "interface TestComponent {",
        "  A a();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final TestModule testModule;",
        "  private Provider<B> bProvider;",
        "  private Provider<A> aProvider;",
        "",
        "  private Dagger_TestComponent(Builder builder) {",
        "    assert builder != null;",
        "    this.testModule = builder.testModule;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static TestComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.bProvider = TestModule$$BFactory.create(testModule, C$$Factory.create());",
        "    this.aProvider = A$$Factory.create(bProvider);",
        "  }",
        "",
        "  @Override",
        "  public A a() {",
        "    return aProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private TestModule testModule;",
        "",
        "    private Builder() {",
        "    }",
        "",
        "    public TestComponent build() {",
        "      if (testModule == null) {",
        "        this.testModule = new TestModule();",
        "      }",
        "      return new Dagger_TestComponent(this);",
        "    }",
        "",
        "    public Builder testModule(TestModule testModule) {",
        "      if (testModule == null) {",
        "        throw new NullPointerException(\"testModule\");",
        "      }",
        "      this.testModule = testModule;",
        "      return this;",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void transitiveModuleDeps() {
    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module",
        "final class AlwaysIncluded {}");
    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
        "final class TestModule extends ParentTestModule {}");
    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
        "class ParentTestModule {}");
    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = AlwaysIncluded.class)",
        "final class ParentTestIncluded {}");
    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
        "final class DepModule extends ParentDepModule {}");
    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = AlwaysIncluded.class)",
        "final class RefByDep extends ParentDepModule {}");
    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
        "class ParentDepModule {}");
    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
        "package test;",
        "",
        "import dagger.Module;",
        "",
        "@Module(includes = AlwaysIncluded.class)",
        "final class ParentDepIncluded {}");

    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = TestModule.class)",
        "interface TestComponent {",
        "}");
    // Generated code includes all includes, but excludes the parent modules.
    // The "always" module should only be listed once.
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final TestModule testModule;",
        "  private final DepModule depModule;",
        "  private final AlwaysIncluded alwaysIncluded;",
        "  private final ParentTestIncluded parentTestIncluded;",
        "  private final RefByDep refByDep;",
        "  private final ParentDepIncluded parentDepIncluded;",
        "",
        "  private Dagger_TestComponent(Builder builder) {",
        "    assert builder != null;",
        "    this.testModule = builder.testModule;",
        "    this.depModule = builder.depModule;",
        "    this.alwaysIncluded = builder.alwaysIncluded;",
        "    this.parentTestIncluded = builder.parentTestIncluded;",
        "    this.refByDep = builder.refByDep;",
        "    this.parentDepIncluded = builder.parentDepIncluded;",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static TestComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private TestModule testModule;",
        "    private DepModule depModule;",
        "    private AlwaysIncluded alwaysIncluded;",
        "    private ParentTestIncluded parentTestIncluded;",
        "    private RefByDep refByDep;",
        "    private ParentDepIncluded parentDepIncluded;",
        "",
        "    private Builder() {",
        "    }",
        "",
        "    public TestComponent build() {",
        "      if (testModule == null) {",
        "        this.testModule = new TestModule();",
        "      }",
        "      if (depModule == null) {",
        "        this.depModule = new DepModule();",
        "      }",
        "      if (alwaysIncluded == null) {",
        "        this.alwaysIncluded = new AlwaysIncluded();",
        "      }",
        "      if (parentTestIncluded == null) {",
        "        this.parentTestIncluded = new ParentTestIncluded();",
        "      }",
        "      if (refByDep == null) {",
        "        this.refByDep = new RefByDep();",
        "      }",
        "      if (parentDepIncluded == null) {",
        "        this.parentDepIncluded = new ParentDepIncluded();",
        "      }",
        "      return new Dagger_TestComponent(this);",
        "    }",
        "",
        "    public Builder testModule(TestModule testModule) {",
        "      if (testModule == null) {",
        "        throw new NullPointerException(\"testModule\");",
        "      }",
        "      this.testModule = testModule;",
        "      return this;",
        "    }",
        "",
        "    public Builder depModule(DepModule depModule) {",
        "      if (depModule == null) {",
        "        throw new NullPointerException(\"depModule\");",
        "      }",
        "      this.depModule = depModule;",
        "      return this;",
        "    }",
        "",
        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
        "      if (alwaysIncluded == null) {",
        "        throw new NullPointerException(\"alwaysIncluded\");",
        "      }",
        "      this.alwaysIncluded = alwaysIncluded;",
        "      return this;",
        "    }",
        "",
        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
        "      if (parentTestIncluded == null) {",
        "        throw new NullPointerException(\"parentTestIncluded\");",
        "      }",
        "      this.parentTestIncluded = parentTestIncluded;",
        "      return this;",
        "    }",
        "",
        "    public Builder refByDep(RefByDep refByDep) {",
        "      if (refByDep == null) {",
        "        throw new NullPointerException(\"refByDep\");",
        "      }",
        "      this.refByDep = refByDep;",
        "      return this;",
        "    }",
        "",
        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
        "      if (parentDepIncluded == null) {",
        "        throw new NullPointerException(\"parentDepIncluded\");",
        "      }",
        "      this.parentDepIncluded = parentDepIncluded;",
        "      return this;",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(always,
            testModule,
            parentTest,
            parentTestIncluded,
            depModule,
            refByDep,
            parentDep,
            parentDepIncluded,
            componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void setBindings() {
    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
        "package test;",
        "",
        "import static dagger.Provides.Type.SET_VALUES;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "import java.util.Collections;",
        "import java.util.Set;",
        "",
        "@Module",
        "final class EmptySetModule {",
        "  @Provides(type = SET_VALUES) Set<String> emptySet() { return Collections.emptySet(); }",
        "}");
    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
        "package test;",
        "",
        "import static dagger.Provides.Type.SET;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "final class SetModule {",
        "  @Provides(type = SET) String string() { return \"\"; }",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import java.util.Set;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = {EmptySetModule.class, SetModule.class})",
        "interface TestComponent {",
        "  Set<String> strings();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import dagger.internal.SetFactory;",
        "import java.util.Set;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final EmptySetModule emptySetModule;",
        "  private final SetModule setModule;",
        "  private Provider<Set<String>> setOfStringContribution1Provider;",
        "  private Provider<Set<String>> setOfStringContribution2Provider;",
        "  private Provider<Set<String>> setOfStringProvider;",
        "",
        "  private Dagger_TestComponent(Builder builder) {",
        "    assert builder != null;",
        "    this.emptySetModule = builder.emptySetModule;",
        "    this.setModule = builder.setModule;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static TestComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.setOfStringContribution1Provider =",
        "        EmptySetModule$$EmptySetFactory.create(emptySetModule);",
        "    this.setOfStringContribution2Provider = SetModule$$StringFactory.create(setModule);",
        "    this.setOfStringProvider = SetFactory.create(",
        "        setOfStringContribution1Provider, setOfStringContribution2Provider);",
        "  }",
        "",
        "  @Override",
        "  public Set<String> strings() {",
        "    return setOfStringProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private EmptySetModule emptySetModule;",
        "    private SetModule setModule;",
        "",
        "    private Builder() {",
        "    }",
        "",
        "    public TestComponent build() {",
        "      if (emptySetModule == null) {",
        "        this.emptySetModule = new EmptySetModule();",
        "      }",
        "      if (setModule == null) {",
        "        this.setModule = new SetModule();",
        "      }",
        "      return new Dagger_TestComponent(this);",
        "    }",
        "",
        "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
        "      if (emptySetModule == null) {",
        "        throw new NullPointerException(\"emptySetModule\");",
        "      }",
        "      this.emptySetModule = emptySetModule;",
        "      return this;",
        "    }",
        "",
        "    public Builder setModule(SetModule setModule) {",
        "      if (setModule == null) {",
        "        throw new NullPointerException(\"setModule\");",
        "      }",
        "      this.setModule = setModule;",
        "      return this;",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void membersInjection() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectedType {",
        "  @Inject SomeInjectableType injectedField;",
        "  SomeInjectedType() {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  void inject(SomeInjectedType instance);",
        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.MembersInjector;",
        "import javax.annotation.Generated;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
        "",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.someInjectedTypeMembersInjector =",
        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
        "  }",
        "",
        "  @Override",
        "  public void inject(SomeInjectedType instance) {",
        "    someInjectedTypeMembersInjector.injectMembers(instance);",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
        "    someInjectedTypeMembersInjector.injectMembers(instance);",
        "    return instance;",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void componentInjection() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType(SimpleComponent component) {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.internal.InstanceFactory;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private Provider<SimpleComponent> simpleComponentProvider;",
        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
        "",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
        "    this.someInjectableTypeProvider =",
        "        SomeInjectableType$$Factory.create(simpleComponentProvider);",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return someInjectableTypeProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void membersInjectionInsideProvision() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectedType {",
        "  @Inject SomeInjectableType injectedField;",
        "  @Inject SomeInjectedType() {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  SomeInjectedType createAndInject();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.MembersInjector;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
        "",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.someInjectedTypeMembersInjector =",
        "        SomeInjectedType$$MembersInjector.create(SomeInjectableType$$Factory.create());",
        "    this.someInjectedTypeProvider =",
        "        SomeInjectedType$$Factory.create(someInjectedTypeMembersInjector);",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectedType createAndInject() {",
        "    return someInjectedTypeProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void injectionWithGenericBaseClass() {
    JavaFileObject genericType = JavaFileObjects.forSourceLines("test.AbstractGenericType",
        "package test;",
        "",
        "abstract class AbstractGenericType<T> {",
        "}");
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType extends AbstractGenericType<String> {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import dagger.MembersInjector;",
        "import dagger.internal.MembersInjectors;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private MembersInjector<AbstractGenericType<String>> abstractGenericTypeMembersInjector;",
        "  private MembersInjector<SomeInjectableType> someInjectableTypeMembersInjector;",
        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
        "",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.abstractGenericTypeMembersInjector = MembersInjectors.noOp();",
        "    this.someInjectableTypeMembersInjector = MembersInjectors.delegatingTo(",
        "        abstractGenericTypeMembersInjector);",
        "    this.someInjectableTypeProvider =",
        "        SomeInjectableType$$Factory.create(someInjectableTypeMembersInjector);",
        "  }",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return someInjectableTypeProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(genericType, injectableTypeFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void componentDependency() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class A {",
        "  @Inject A() {}",
        "}");
    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class B {",
        "  @Inject B(A a) {}",
        "}");
    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface AComponent {",
        "  A a();",
        "}");
    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(dependencies = AComponent.class)",
        "interface BComponent {",
        "  B b();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_BComponent",
        "package test;",
        "",
        "import dagger.Factory;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_BComponent implements BComponent {",
        "  private final AComponent aComponent;",
        "  private Provider<A> aProvider;",
        "  private Provider<B> bProvider;",
        "",
        "  private Dagger_BComponent(Builder builder) {",
        "    assert builder != null;",
        "    this.aComponent = builder.aComponent;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.aProvider = new Factory<A>() {",
        "      @Override public A get() {",
        "        return aComponent.a();",
        "      }",
        "    };",
        "    this.bProvider = B$$Factory.create(aProvider);",
        "  }",
        "",
        "  @Override",
        "  public B b() {",
        "    return bProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private AComponent aComponent;",
        "",
        "    private Builder() {",
        "    }",
        "",
        "    public BComponent build() {",
        "      if (aComponent == null) {",
        "        throw new IllegalStateException(\"aComponent must be set\");",
        "      }",
        "      return new Dagger_BComponent(this);",
        "    }",
        "",
        "    public Builder aComponent(AComponent aComponent) {",
        "      if (aComponent == null) {",
        "        throw new NullPointerException(\"aComponent\");",
        "      }",
        "      this.aComponent = aComponent;",
        "      return this;",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void moduleNameCollision() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
        "public final class A {}");
    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
        "package other.test;",
        "",
        "public final class A {}");

    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
        "package test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "public final class TestModule {",
        "  @Provides A a() { return null; }",
        "}");
    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
        "package other.test;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "public final class TestModule {",
        "  @Provides A a() { return null; }",
        "}");

    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
        "interface TestComponent {",
        "  A a();",
        "  other.test.A otherA();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "import other.test.A;",
        "import other.test.TestModule;",
        "import other.test.TestModule$$AFactory;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final test.TestModule testModule;",
        "  private final TestModule testModule1;",
        "  private Provider<test.A> aProvider;",
        "  private Provider<A> aProvider1;",
        "",
        "  private Dagger_TestComponent(Builder builder) {",
        "    assert builder != null;",
        "    this.testModule = builder.testModule;",
        "    this.testModule1 = builder.testModule1;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static TestComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.aProvider = test.TestModule$$AFactory.create(testModule);",
        "    this.aProvider1 = TestModule$$AFactory.create(testModule1);",
        "  }",
        "",
        "  @Override",
        "  public test.A a() {",
        "    return aProvider.get();",
        "  }",
        "",
        "  @Override",
        "  public A otherA() {",
        "    return aProvider1.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private test.TestModule testModule;",
        "    private TestModule testModule1;",
        "",
        "    private Builder() {",
        "    }",
        "",
        "    public TestComponent build() {",
        "      if (testModule == null) {",
        "        this.testModule = new test.TestModule();",
        "      }",
        "      if (testModule1 == null) {",
        "        this.testModule1 = new TestModule();",
        "      }",
        "      return new Dagger_TestComponent(this);",
        "    }",
        "",
        "    public Builder testModule(test.TestModule testModule) {",
        "      if (testModule == null) {",
        "        throw new NullPointerException(\"testModule\");",
        "      }",
        "      this.testModule = testModule;",
        "      return this;",
        "    }",
        "",
        "    public Builder testModule(TestModule testModule) {",
        "      if (testModule == null) {",
        "        throw new NullPointerException(\"testModule\");",
        "      }",
        "      this.testModule1 = testModule;",
        "      return this;",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void resolutionOrder() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class A {",
        "  @Inject A(B b) {}",
        "}");
    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class B {",
        "  @Inject B(C c) {}",
        "}");
    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class C {",
        "  @Inject C() {}",
        "}");
    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class X {",
        "  @Inject X(C c) {}",
        "}");

    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface TestComponent {",
        "  A a();",
        "  C c();",
        "  X x();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private Provider<B> bProvider;",
        "  private Provider<A> aProvider;",
        "  private Provider<X> xProvider;",
        "",
        "  private Dagger_TestComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static TestComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {",
        "    this.bProvider = B$$Factory.create(C$$Factory.create());",
        "    this.aProvider = A$$Factory.create(bProvider);",
        "    this.xProvider = X$$Factory.create(C$$Factory.create());",
        "  }",
        "",
        "  @Override",
        "  public A a() {",
        "    return aProvider.get();",
        "  }",
        "",
        "  @Override",
        "  public C c() {",
        "    return C$$Factory.create().get();",
        "  }",
        "",
        "  @Override",
        "  public X x() {",
        "    return xProvider.get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public TestComponent build() {",
        "      return new Dagger_TestComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources())
        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void simpleComponent_redundantComponentMethod() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SupertypeA {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SupertypeB {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent extends SupertypeA, SupertypeB {",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {}",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return SomeInjectableType$$Factory.create().get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(
            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void simpleComponent_inheritedComponentMethodDep() {
    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class SomeInjectableType {",
        "  @Inject SomeInjectableType() {}",
        "}");
    JavaFileObject componentSupertype = JavaFileObjects.forSourceLines("test.Supertype",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface Supertype {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject depComponentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent extends Supertype {",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithDep",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(dependencies = SimpleComponent.class)",
        "interface ComponentWithDep {",
        "  SomeInjectableType someInjectableType();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_SimpleComponent",
        "package test;",
        "",
        "import javax.annotation.Generated;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_SimpleComponent implements SimpleComponent {",
        "  private Dagger_SimpleComponent(Builder builder) {",
        "    assert builder != null;",
        "    initialize();",
        "  }",
        "",
        "  public static Builder builder() {",
        "    return new Builder();",
        "  }",
        "",
        "  public static SimpleComponent create() {",
        "    return builder().build();",
        "  }",
        "",
        "  private void initialize() {}",
        "",
        "  @Override",
        "  public SomeInjectableType someInjectableType() {",
        "    return SomeInjectableType$$Factory.create().get();",
        "  }",
        "",
        "  public static final class Builder {",
        "    private Builder() {",
        "    }",
        "",
        "    public SimpleComponent build() {",
        "      return new Dagger_SimpleComponent(this);",
        "    }",
        "  }",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(
            injectableTypeFile, componentSupertype, depComponentFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }

  @Test public void wildcardGenericsRequiresAtProvides() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "",
        "final class A {",
        "  @Inject A() {}",
        "}");
    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "import javax.inject.Provider;",
        "",
        "final class B<T> {",
        "  @Inject B(T t) {}",
        "}");
    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
        "package test;",
        "",
        "import javax.inject.Inject;",
        "import javax.inject.Provider;",
        "",
        "final class C {",
        "  @Inject C(B<? extends A> bA) {}",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import dagger.Lazy;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component",
        "interface SimpleComponent {",
        "  C c();",
        "}");
    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))
        .processedWith(new ComponentProcessor())
        .failsToCompile()
        .withErrorContaining(
            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
  }
 
  @Test
  @Ignore // modify this test as necessary while debugging for your situation.
  @SuppressWarnings("unused")
  public void genericTestToLetMeDebugInEclipse() {
    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
        "package test;",
        "",
         "import javax.inject.Inject;",
         "",
         "public final class A {",
         "  @Inject A() {}",
         "}");
     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
         "package test;",
         "",
         "import javax.inject.Inject;",
         "import javax.inject.Provider;",
         "",
         "public class B<T> {",
         "  @Inject B() {}",
         "}");
     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
         "package test.sub;",
         "",
         "import javax.inject.Inject;",
         "import javax.inject.Provider;",
         "import test.B;",
         "",
         "public class D {",
         "  @Inject D(B<A.InA> ba) {}",
         "}");
     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
         "package test;",
         "",
         "import dagger.Component;",
         "import dagger.Lazy;",
         "",
         "import javax.inject.Provider;",
         "",
         "@Component",
         "interface SimpleComponent {",
         "  B<A> d();",
         "  Provider<B<A>> d2();",
         "}");
     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
         "test.Dagger_SimpleComponent",
         "package test;",
         "",
         "import javax.annotation.Generated;",
         "import javax.inject.Provider;",
         "",
         "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
         "public final class Dagger_SimpleComponent implements SimpleComponent {",
         "  private Provider<D> dProvider;",
         "",
         "  private Dagger_SimpleComponent(Builder builder) {",
         "    assert builder != null;",
         "    initialize();",
         "  }",
         "",
         "  public static Builder builder() {",
         "    return new Builder();",
         "  }",
         "",
         "  public static SimpleComponent create() {",
         "    return builder().build();",
         "  }",
         "",
         "  private void initialize() {",
         "    this.dProvider = new D$$Factory(B$$Factory.INSTANCE);",
         "  }",
         "",
         "  @Override",
         "  public D d() {",
         "    return dProvider.get();",
         "  }",
         "",
         "  public static final class Builder {",
         "    private Builder() {",
         "    }",
         "",
         "    public SimpleComponent build() {",
         "      return new Dagger_SimpleComponent(this);",
         "    }",
         "  }",
         "}");
     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))
         .processedWith(new ComponentProcessor())
         .compilesWithoutError()
         .and().generatesSources(generatedComponent);
   }
}
