/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.common.collect.Iterables.concat;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static java.util.Arrays.asList;
import static org.truth0.Truth.ASSERT;

/**
 * Tests that the annotation processor(s) will properly handle the case where
 * code they are processing and depending on is generated by other processors
 * in the environment, and so the types they need may not exist yet.
 */
@RunWith(JUnit4.class)
public class GeneratedTypesNotReadyTest {
  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", Joiner.on("\n").join(
      "package myPackage;",
      "public interface Foo {}"
  ));
  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
      "import javax.inject.Inject;",
      "import myPackage.Foo;",
      "class Main {",
      "  @Inject Foo f;",
      "}"));

  @Test public void withstandsMissingTypeReferencedInInjects() {
    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class, myPackage.FooImpl.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, main, module))
        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedInsideModule() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class Main {",
        "  @Inject myPackage.FooImpl f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides myPackage.FooImpl provideFoo() {",
        "    return new myPackage.FooImpl();",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class Main {",
        "  @Inject myPackage.FooImpl2<String> f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
        "    return new myPackage.FooImpl2<String>();",
        "  }",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .failsToCompile()
        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
  }

  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "import myPackage.FooImpl;",
        "class Main {",
        "  @Inject FooImpl f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "}"));

    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "import myPackage.Foo;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides Foo provideFoo(myPackage.FooImpl impl) {",
        "    return impl;",
        "  }",
        "}"));
    ASSERT.about(javaSources()).that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
  }

  @SupportedAnnotationTypes("*")
  private final class FooImplGenerator extends AbstractProcessor {
    boolean written = false;
    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
      if (!written) {
        try {
          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
          Writer writer = sourceFile.openWriter();
          writer.write(Joiner.on("\n").join(
              "package myPackage;",
              "import javax.inject.Inject;",
              "public final class FooImpl implements Foo {",
              "  @Inject public FooImpl() { }",
              "}"));
          writer.close();
          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
          writer = sourceFile.openWriter();
          writer.write(Joiner.on("\n").join(
              "package myPackage;",
              "import javax.inject.Inject;",
              "public final class FooImpl2<T> implements Foo {",
              "  @Inject public FooImpl2() { }",
              "}"));
          writer.close();
          written = true;
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return false;
    }

    @Override public SourceVersion getSupportedSourceVersion() {
      return SourceVersion.latestSupported();
    }
  }

}
