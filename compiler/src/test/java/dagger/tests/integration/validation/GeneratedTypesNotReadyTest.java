/**
 * Copyright (c) 2013 Google, Inc.
 * Copyright (c) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.tests.integration.validation;

import com.google.common.base.Joiner;
import com.google.testing.compile.JavaFileObjects;
import java.io.IOException;
import java.io.Writer;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.tools.JavaFileObject;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import static com.google.common.collect.Iterables.concat;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static dagger.tests.integration.ProcessorTestUtils.daggerProcessors;
import static java.util.Arrays.asList;
import static com.google.common.truth.Truth.assertAbout;

/**
 * Tests that the annotation processor(s) will properly handle the case where
 * code they are processing and depending on is generated by other processors
 * in the environment, and so the types they need may not exist yet.
 */
@RunWith(JUnit4.class)
public class GeneratedTypesNotReadyTest {
  private final JavaFileObject foo = JavaFileObjects.forSourceString("Foo", ""
      + "package myPackage;\n"
      + "public interface Foo {}\n"
  );
  private final JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
      + "import javax.inject.Inject;\n"
      + "import myPackage.Foo;\n"
      + "class Main {\n"
      + "  @Inject Foo f;\n"
      + "}\n"
  );

  @Test public void withstandsMissingTypeReferencedInInjects() {
    // TODO(cgruber): remove Foo (interface) from this when injects= analysis is fixed.
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
        + "import dagger.Module;\n"
        + "import dagger.Provides;\n"
        + "import myPackage.Foo;\n"
        + "@Module(injects = { Main.class, myPackage.FooImpl.class })\n"
        + "class FooModule {\n"
        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
        + "    return impl;\n"
        + "  }\n"
        + "}\n"
    );

    assertAbout(javaSources())
        .that(asList(foo, main, module))
        .processedWith(concat(asList(new FooImplGenerator()), daggerProcessors()))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedInsideModule() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
        + "import dagger.Module;\n"
        + "import dagger.Provides;\n"
        + "import myPackage.Foo;\n"
        + "@Module(injects = { Main.class })\n"
        + "class FooModule {\n"
        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
        + "    return impl;\n"
        + "  }\n"
        + "}\n"
    );

    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void withstandsMissingTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
        + "import javax.inject.Inject;\n"
        + "class Main {\n"
        + "  @Inject myPackage.FooImpl f;\n"
        + "}\n"
    );
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
        + "import dagger.Module;\n"
        + "import dagger.Provides;\n"
        + "@Module(injects = { Main.class })\n"
        + "class FooModule {\n"
        + "  @Provides myPackage.FooImpl provideFoo() {\n"
        + "    return new myPackage.FooImpl();\n"
        + "  }\n"
        + "}\n"
    );

    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void failsWhenMissingGenericTypeReferencedByProvidesReturnType() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", Joiner.on("\n").join(
        "import javax.inject.Inject;",
        "class Main {",
        "  @Inject myPackage.FooImpl2<String> f;",
        "}"));
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", Joiner.on("\n").join(
        "import dagger.Module;",
        "import dagger.Provides;",
        "@Module(injects = { Main.class })",
        "class FooModule {",
        "  @Provides myPackage.FooImpl2<String> provideFoo() {",
        "    return new myPackage.FooImpl2<String>();",
        "  }",
        "}"));

    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .failsToCompile()
        .withErrorContaining("Could not find types required by provides methods for [FooModule]");
  }

  @Test public void withstandsMissingTypeReferencedInTransitiveJITDependency() {
    JavaFileObject main = JavaFileObjects.forSourceString("Main", ""
        + "import javax.inject.Inject;\n"
        + "import myPackage.FooImpl;\n"
        + "class Main {\n"
        + "  @Inject FooImpl f;\n"
        + "}\n"
    );
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
        + "import dagger.Module;\n"
        + "import dagger.Provides;\n"
        + "@Module(injects = { Main.class })\n"
        + "class FooModule {\n"
        + "}\n"
    );

    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(concat(daggerProcessors(), asList(new FooImplGenerator())))
        .compilesWithoutError();
  }

  @Test public void verifyFooImplGeneratorIsCompilingWithoutDagger() {
    JavaFileObject module = JavaFileObjects.forSourceString("FooModule", ""
        + "import dagger.Module;\n"
        + "import dagger.Provides;\n"
        + "import myPackage.Foo;\n"
        + "@Module(injects = { Main.class })\n"
        + "class FooModule {\n"
        + "  @Provides Foo provideFoo(myPackage.FooImpl impl) {\n"
        + "    return impl;\n"
        + "  }\n"
        + "}\n"
    );
    assertAbout(javaSources())
        .that(asList(foo, module, main))
        .processedWith(new FooImplGenerator())
        .compilesWithoutError();
  }

  @SupportedAnnotationTypes("*")
  private final class FooImplGenerator extends AbstractProcessor {
    boolean written = false;
    @Override public boolean process(Set<? extends TypeElement> na1, RoundEnvironment na2) {
      if (!written) {
        try {
          JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile("FooImpl");
          Writer writer = sourceFile.openWriter();
          writer.write(""
              + "package myPackage;\n"
              + "import javax.inject.Inject;\n"
              + "public final class FooImpl implements Foo {\n"
              + "  @Inject public FooImpl() { }\n"
              + "}\n"
          );
          writer.close();
          sourceFile = processingEnv.getFiler().createSourceFile("FooImpl2");
          writer = sourceFile.openWriter();
          writer.write(""
              + "package myPackage;\n"
              + "import javax.inject.Inject;\n"
              + "public final class FooImpl2<T> implements Foo {\n"
              + "  @Inject public FooImpl2() { }\n"
              + "}\n"
          );
          writer.close();
          written = true;
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
      return false;
    }

    @Override public SourceVersion getSupportedSourceVersion() {
      return SourceVersion.latestSupported();
    }
  }

}
