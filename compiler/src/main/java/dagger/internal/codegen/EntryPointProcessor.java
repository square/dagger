/*
 * Copyright (C) 2012 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import static javax.lang.model.util.ElementFilter.typesIn;
import static javax.tools.StandardLocation.SOURCE_OUTPUT;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.StandardLocation;

import dagger.EntryPoint;
import dagger.Module;

/**
 * Generates a new non complete {@link Module} that contains all entry points
 * annotated with {@link EntryPoint}
 */
@SupportedAnnotationTypes("dagger.EntryPoint")
@SupportedSourceVersion(SourceVersion.RELEASE_6)
public class EntryPointProcessor extends AbstractProcessor {

  private static final String ENTRY_POINTS_MODULE_PACKAGE_OPTION_KEY = "entryPointsModulePackage";
  private static final String ENTRY_POINTS_MODULE_OPTION_KEY = "entryPointsModule";
  private static final String DEFAULT_ENTRY_POINTS_MODULE_PACKAGE = "dagger.generated";
  private static final String DEFAULT_ENTRY_POINTS_MODULE_NAME = "EntryPointsModule";
  private static final String CACHE_PACKAGE = DEFAULT_ENTRY_POINTS_MODULE_PACKAGE;
  private static final String CACHE_FILE = "EntryPointProcessorCache.txt";

  /**
   * We can't work on the same files at each round, so we only care about the
   * first rounds. This means that we do not handle annotations on file
   * generated by another processor.
   */
  boolean alreadyProcessed = false;

  @Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {

    if (alreadyProcessed) {
      return false;
    } else {
      alreadyProcessed = true;
    }

    Set<TypeElement> roundEntryPoints = roundEntryPoints(env);
    Set<TypeElement> cachedEntryPoints = cachedEntryPoints();
    List<String> sortedEntryPoints = sortedMergedEntryPoints(roundEntryPoints, cachedEntryPoints);
    generateEntryPointsModule(sortedEntryPoints, packageName(), moduleName());
    cacheEntryPoints(sortedEntryPoints);

    return true;
  }

  /**
   * @return the {@link TypeElement}s annotated with {@link EntryPoint} included
   *         in this round of annotation processing.
   */
  private Set<TypeElement> roundEntryPoints(RoundEnvironment roundEnv) {
    return typesIn(roundEnv.getElementsAnnotatedWith(EntryPoint.class));
  }

  private Set<TypeElement> cachedEntryPoints() {
    Filer filer = processingEnv.getFiler();
    Elements elementUtils = processingEnv.getElementUtils();
    try {
      FileObject resource = filer.getResource(SOURCE_OUTPUT, CACHE_PACKAGE, CACHE_FILE);
      /*
       * TODO do we want to ignore encoding errors?
       */
      final boolean ignoreEncodingErrors = true;
      BufferedReader reader = new BufferedReader(resource.openReader(ignoreEncodingErrors));
      Set<TypeElement> cachedEntryPoints = new HashSet<TypeElement>();
      String entryPointQualifiedName;
      while ((entryPointQualifiedName = reader.readLine()) != null) {
        if (entryPointQualifiedName.startsWith("#")) {
          continue;
        }
        TypeElement entryPoint = elementUtils.getTypeElement(entryPointQualifiedName);

        boolean isValidEntryPoint = entryPoint != null
            && entryPoint.getAnnotation(EntryPoint.class) != null;

        if (isValidEntryPoint) {
          cachedEntryPoints.add(entryPoint);
        }
      }
      reader.close();
      return cachedEntryPoints;
    } catch (Exception e) {
      /*
       * The cache file may not exist, in case of first build or full build.
       */
      return Collections.emptySet();
    }
  }

  private List<String> sortedMergedEntryPoints(Set<TypeElement> roundEntryPoints,
      Set<TypeElement> cachedEntryPoints) {

    Set<TypeElement> entryPoints = new HashSet<TypeElement>();
    entryPoints.addAll(roundEntryPoints);
    entryPoints.addAll(cachedEntryPoints);

    List<String> entryPointQualifiedNames = new ArrayList<String>(entryPoints.size());
    for (TypeElement entryPoint : entryPoints) {
      entryPointQualifiedNames.add(entryPoint.getQualifiedName().toString());
    }
    Collections.sort(entryPointQualifiedNames);
    return entryPointQualifiedNames;
  }

  private String moduleName() {
    String moduleName;
    Map<String, String> options = processingEnv.getOptions();
    if (options.containsKey(ENTRY_POINTS_MODULE_OPTION_KEY)) {
      moduleName = options.get(ENTRY_POINTS_MODULE_OPTION_KEY);
    } else {
      moduleName = DEFAULT_ENTRY_POINTS_MODULE_NAME;
    }
    return moduleName;
  }

  private String packageName() {
    String packageName;
    Map<String, String> options = processingEnv.getOptions();
    if (options.containsKey(ENTRY_POINTS_MODULE_PACKAGE_OPTION_KEY)) {
      packageName = options.get(ENTRY_POINTS_MODULE_PACKAGE_OPTION_KEY);
    } else {
      packageName = DEFAULT_ENTRY_POINTS_MODULE_PACKAGE;
    }
    return packageName;
  }

  private void generateEntryPointsModule(List<String> sortedEntryPoints, String packageName,
      String moduleName) {

    String[] entryPointclassLiterals = new String[sortedEntryPoints.size()];

    for (int i = 0; i < entryPointclassLiterals.length; i++) {
      entryPointclassLiterals[i] = sortedEntryPoints.get(i) + ".class";
    }

    Filer filer = processingEnv.getFiler();
    try {
      JavaFileObject sourceFile = filer.createSourceFile(packageName + "." + moduleName);

      JavaWriter writer = new JavaWriter(sourceFile.openWriter());

      writer.addPackage(packageName);
      writer.addImport(Module.class);

      Map<String, Object> sortedAttributes = new LinkedHashMap<String, Object>();
      sortedAttributes.put("entryPoints", entryPointclassLiterals);
      sortedAttributes.put("complete", "false");

      writer.annotation(Module.class, sortedAttributes);

      writer.beginType(moduleName, "class", Modifier.PUBLIC | Modifier.FINAL);
      writer.endType();

      writer.close();
    } catch (IOException e) {
      error("Unable to generate entry points module", e);
    }
  }

  private void cacheEntryPoints(List<String> sortedEntryPoints) {
    try {
      JavaFileManager.Location location = StandardLocation.SOURCE_OUTPUT;
      Filer filer = processingEnv.getFiler();
      FileObject resource = filer.createResource(location, CACHE_PACKAGE, CACHE_FILE);

      BufferedWriter writer = new BufferedWriter(resource.openWriter());
      writer.write("# This file has been generated");
      writer.newLine();
      for (String entryPoint : sortedEntryPoints) {
        writer.write(entryPoint);
        writer.newLine();
      }
      writer.close();
    } catch (IOException e) {
      /*
       * Cannot create a previously opened resource in case of full maven build.
       */
    }
  }

  private void error(String message, Throwable throwable) {
    String fullMessage = messageWithStacktrace(message, throwable);
    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, fullMessage);
  }

  private String messageWithStacktrace(String message, Throwable throwable) {
    StringWriter writer = new StringWriter();
    PrintWriter printWriter = new PrintWriter(writer);
    printWriter.write(message);
    printWriter.write("\n");
    throwable.printStackTrace(printWriter);
    return writer.toString();
  }

}
